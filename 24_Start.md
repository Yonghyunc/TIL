# Today I Learned
- SW 문제 해결 과정
- 복잡도 분석
- 비트 연산

<br><br>

---

# SW 문제 해결 과정
1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 계획을 검증한다
5. 프로그램으로 구현한다
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다


<br><br>

---

# 복잡도 분석  

🔹 알고리즘 : 문제를 해결하기 위한 절차나 방법  
🔹 알고리즘의 효율
- 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 요하는가
- 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 요하는가

**복잡도(complexiy) <-> 효율성**

<br>

🔹 시간적 복잡도 분석  
복잡도의 점근적 표기  
➡ 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용  
- Big-O   
  - 복잡도의 점근적 상한 
- Big-Omaga  
  - 복잡도의 점근적 하한 (최소한 이만한 시간은 걸린다)
- Big-Theta

> 표기방법은 같은데, 해석이 다름  
> O : 최악의 경우에는 그걸 넘어가지는 않아  
> Omega : 그건 넘을거야

<br>

🔹 자주 사용하는 O-표기

|            |                |
| :--------: | :------------: |
|    O(1)    |   상수 시간    |
|  O(log n)  |   로그 시간    |
|    O(n)    |   선형 시간    |
| O(n log n) | 로그 선형 시간 |
|   O(n^2)   |   제곱 시간    |
|   O(n^3)   |  세제곱 시간   |
|   O(2^n)   |   지수 시간    |


<br>

🔹 왜 효율적인 알고리즘이 필요 ?  
➡ 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다 (훨씬 경제적)


<br><br>

---

# 표준 입출력 방법
### Python3 표준입출력  
<br>

🔹 입력
- raw 값 입력 : input()
  - 받은 입력값을 문자열로 취급
- evaluated된 값 입력 : eval(input())
  - 받은 입력값을 평가된 데이터 형으로 취급  

🔹 출력
- print() : 표준 출력 함수, 출력값의 마지막에 개행 문자 포함
- print('text', end='') : 마지막의 개행문자 제거
- print('%d' % number) : Formatting 된 출력

🔹 파일의 내용을 표준 입력으로 불러오는 방법  
  ``` python
  import sys  
  sys.stdin = open("a.txt", "r") 
  ``` 

> ❕ 반드시 써야하는 경우  
> pycharm의 console에 복사-붙여넣기 크기 1MB로 제한
> ➡ 1MB가 넘어가는 대용량의 파일은 console 창에 붙여넣기 불가


<br><br>

---

# 비트 연산

🔹 비트 연산자
<img width="450" src=https://user-images.githubusercontent.com/93974908/190975878-23891c84-ee2d-474d-998a-f8b03e815393.png alt="비트연산자">


