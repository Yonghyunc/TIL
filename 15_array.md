# 배열
- [알고리즘](#알고리즘)
- [배열](#배열)
- [버블 정렬](#1-버블-정렬)
- [카운팅 정렬](#2-카운팅-정렬)
- [완전검색](#완전-검색)
- [그리디 알고리즘](#탐욕greedy-알고리즘)

<br/><br/>

---
# 알고리즘
- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 어떠한 문제를 해결하기 위한 절차
<br/>

- 컴퓨터 분야에서 알고리즘 표현하는 방법
  - 의사코드
  - 순서도

<br/>

---

### ❗보다 좋은 알고리즘을 이해하고 활용!!!

<br/>


## 알고리즘 성능 측정
1. 정확성
2. 작업량
3. 메모리 사용량
4. 단순성
5. 최적성

- 주어진 문제 해결에는 여러 개의 다양한 알고리즘 사용 가능 -> 알고리즘 성능 분석 통해 사용할 알고리즘 선택

<br/>

## 시간 복잡도 (Time Complexity)
- 알고리즘의 작업량 표현
- 실제 걸리는 시간 측정
- 실행되는 명령문의 개수 계산

### 📍 빅-오(O) 표기법
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- O(1), O(n), O(log n) 등

  <img width="500" src=https://i.esdrop.com/d/f/GQtKpTuAPv/pZqbGw9TgM.png alt="big-O">

<br/><br/>

---

# 배열
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- ex) 리스트

<br/>

### ❓필요성
- 하나의 선언을 통해 둘 이상의 변수 선언 가능
- 다수의 변수로는 하기 힘든 작업을 쉽게 할 수 있음

<br/>

### 1차원 배열 선언
- 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성 <br/>
arr = list() <br/>
arr = [] <br/>
arr = [1, 2, 3] <br/> 
arr = [0] * 10   (1차원 배열에서만 사용 가능한 방법)


<br/><br/>

---


**자료구조(저장) -> 알고리즘(처리)**

<br/>

# 정렬
- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것
- **키** : 자료를 정렬하는 기준이 되는 특정 값 


<br/>

<종류>
1. 버블 정렬 (Bubble Sort)
2. 카운팅 정렬 (Counting Sort)
3. 선택 정렬 (Selection Sort)
4. 퀵 정렬 (Quick Sort)
5. 삽입 정렬 (Insertion Sort)
6. 병합 정렬 (Merge Sort)


<br/>

## 1. 버블 정렬
인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식 <br/>

원소 하나하나를 크기 순으로 교체

- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬

- 시간 복잡도 : O(n^2)

 #### 🔗 [bubble_sort.py](https://github.com/Yonghyunc/TIL/blob/master/code/bubble_sort.py)

<br/>

## 2. 카운팅 정렬
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘  <br/>

숫자를 세서 정렬 / 비교연산 X  <br/>

공간을 많이 써서 속도를 단축 (숫자를 셀 counter 리스트가 필요)  <br/>

개수를 센 다음 그 원소가 몇 번째인지 알려줌 (위치로 정렬)

- 제한 사항
  - 정수(정수로 표현할 수 있는 자료)에 대해서만 적용 O : 정수 항목으로 인덱스 되는 카운트들의 배열 사용
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

- 시간 복잡도 : O(n + k)
  - n : 리스트 길이
  - k : 정수의 최대값

 #### 🔗 [counting_sort.py](https://github.com/Yonghyunc/TIL/blob/master/code/counting_sort.py)

 <br/> <br/>

 ---

 ## 완전 검색 
 - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
 - 모든 경우의 수 테스트 후, 최종 해법 도출
 - 경우의 수가 상대적으로 작을 때 유용

### 순열 (Permutation)
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열 : nPr
- nPr = n * (n - 1) * (n -2) * ... * (n - r  + 1)
- nPn = n! (팩토리얼)
- n! = n + (n - 1) * (n - 2) * ... * 2 * 1


 <br/> <br/>

---

## 탐욕(Greedy) 알고리즘
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
1. 해 선택
2. 실행 가능성 검사
3. 해 검사