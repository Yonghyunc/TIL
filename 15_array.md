# 배열
- [알고리즘](#알고리즘)
- [배열](#배열)
- [버블 정렬](#1-버블-정렬)
- [카운팅 정렬](#2-카운팅-정렬)
- [완전검색](#완전-검색)
- [그리디 알고리즘](#탐욕greedy-알고리즘)

<br/>

# 배열2
- 2차원 배열
- 부분집합 생성
- 바이너리 서치
- 셀렉션 알고리즘
- 선택 정렬

<br/><br/>

---
# 알고리즘
- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 어떠한 문제를 해결하기 위한 절차
<br/>

- 컴퓨터 분야에서 알고리즘 표현하는 방법
  - 의사코드
  - 순서도

<br/>

---

### ❗보다 좋은 알고리즘을 이해하고 활용!!!

<br/>


## 알고리즘 성능 측정
1. 정확성
2. 작업량
3. 메모리 사용량
4. 단순성
5. 최적성

- 주어진 문제 해결에는 여러 개의 다양한 알고리즘 사용 가능 -> 알고리즘 성능 분석 통해 사용할 알고리즘 선택

<br/>

## 시간 복잡도 (Time Complexity)
- 알고리즘의 작업량 표현
- 실제 걸리는 시간 측정
- 실행되는 명령문의 개수 계산

### 📍 빅-오(O) 표기법
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- O(1), O(n), O(log n) 등

  <img width="500" src=https://i.esdrop.com/d/f/GQtKpTuAPv/pZqbGw9TgM.png alt="big-O">

<br/><br/>

---

# 배열
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- ex) 리스트

<br/>

### ❓필요성
- 하나의 선언을 통해 둘 이상의 변수 선언 가능
- 다수의 변수로는 하기 힘든 작업을 쉽게 할 수 있음

<br/>

### 1차원 배열 선언
- 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성 <br/>
arr = list() <br/>
arr = [] <br/>
arr = [1, 2, 3] <br/> 
arr = [0] * 10   (1차원 배열에서만 사용 가능한 방법)


<br/><br/>

---


**자료구조(저장) -> 알고리즘(처리)**

<br/>

# 정렬
- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것
- **키** : 자료를 정렬하는 기준이 되는 특정 값 


<br/>

<종류>
1. 버블 정렬 (Bubble Sort)
2. 카운팅 정렬 (Counting Sort)
3. 선택 정렬 (Selection Sort)
4. 퀵 정렬 (Quick Sort)
5. 삽입 정렬 (Insertion Sort)
6. 병합 정렬 (Merge Sort)


<br/><br/>

## 1. 버블 정렬
인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식 <br/>

원소 하나하나를 크기 순으로 교체

- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬

- 시간 복잡도 : O(n^2)

 #### 🔗 [bubble_sort.py](https://github.com/Yonghyunc/TIL/blob/master/code/bubble_sort.py)

<br/><br/>

## 2. 카운팅 정렬
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘  <br/>

숫자를 세서 정렬 / 비교연산 X  <br/>

공간을 많이 써서 속도를 단축 (숫자를 셀 counter 리스트가 필요)  <br/>

개수를 센 다음 그 원소가 몇 번째인지 알려줌 (위치로 정렬)

- 제한 사항
  - 정수(정수로 표현할 수 있는 자료)에 대해서만 적용 O : 정수 항목으로 인덱스 되는 카운트들의 배열 사용
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

- 시간 복잡도 : O(n + k)
  - n : 리스트 길이
  - k : 정수의 최대값

 #### 🔗 [counting_sort.py](https://github.com/Yonghyunc/TIL/blob/master/code/counting_sort.py)

 <br/> <br/>

 ---

 ## 완전 검색 
 - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
 - 모든 경우의 수 테스트 후, 최종 해법 도출
 - 경우의 수가 상대적으로 작을 때 유용

### 📌 순열 (Permutation)
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열 : nPr
- nPr = n * (n - 1) * (n -2) * ... * (n - r  + 1)
- nPn = n! (팩토리얼)
- n! = n + (n - 1) * (n - 2) * ... * 2 * 1


 <br/> <br/>

---

## 탐욕(Greedy) 알고리즘
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
1. 해 선택
2. 실행 가능성 검사
3. 해 검사

 <br/> <br/>

---

# 2차원 배열

### 선언
- 1차원 List를 묶어놓은 List (List = 배열)
- 다차원 List는 차원에 따라 인덱스 선언 <br/>
arr = [[0, 1, 2, 3], [4, 5, 6, 7]]

``` python
'''
3
1 2 3
4 5 6
7 8 9
'''
N = int(input())
arr =[list(map(int , input().split())) for _ in range(N)]
# 입력 숫자 사이 공백 있으면 => split()

'''
3
123
456
789
'''
N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
```

#### 🔗 [2차원 배열 연습.py](https://github.com/Yonghyunc/TIL/blob/master/code/list2_ex1.py)

<br/><br/>

### 📌 배열 순회
2차원 배열의 모든 원소를 빠짐없이 조사 --> 이중 for문

``` python
# n X m 배열

for i in range(n):
  for j in range(m):
    array[i][j] # 필요한 연산 수행
```

``` python
# 지그재그 순회

for i in range(n):
  for j in range(m):
    array[i][j + (m - 1 - 2 * j) * (i % 2)]
    # 필요한 연산 수행
```

<br/><br/>

### 📌 델타
어떤 원소를 중심으로 주변 원소를 탐색 <br/>
`di = [0, 0, -1, 1] # 상하좌우` <br/>
`dj = [-1, 1, 0, 0]`
#### 🔗 [delta.py](https://github.com/Yonghyunc/TIL/blob/master/code/delta.py)

<br/><br/>

### 📌 전치 행렬
``` python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

'''
1 2 3     1 4 7
4 5 6  => 2 5 8
7 8 9     3 6 9
'''

for i in range(3):
  for j in range(3): 
    if i < j :
      arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

<br/><br/>

---

## 부분집합 
완전검색 기법을 사용하려면, 집합의 모든 부분집합을 생성한 후 각 부분집합의 합을 계산

<br/>

### 📌 부분집합 수
- 원소 n개 -> 부분집합 2^n개
> {1, 2, 3, 4} <br/>
> 2 x 2 x 2 x 2 = 2^4 = 16
> 
> 2 = 포함 or 미포함


<br/>


### 📌 비트 연산자 
> 비트 : 주소로 구분되는 최소 단위 (= 8개의 바이트)
  - `&` : 비트 단위로 AND 연산
  - `|` : 비트 단위로 OR 연산
  - `<<` : 피연산자의 비트 열을 왼쪽으로 이동
  - `>>` : 피연산자의 비트 열을 오른쪽으로 이동

<br/>

☑️ **`&` 연산자** 
- 내가 필요한 비트만 남기고 나머지는 0으로 만들 때 사용
- 0 & _ == 0
- 1 & _ == 원래 값

<br/>

☑️ **`<<` 연산자**
- 2^n (n개 원소의 모든 부분집합의 수) <br/>
- 1 << j : 2의 j제곱 = j번 비트 = 비트 j

<br/>

> **i & (1 << j)** <br/>
> i에 대입한 비트를 검사 <br/>
>
> => j번째 비트가 0이면 0 <br/>
> => j번째 비트가 1이면 0이 아닌 결과

<br/>

``` python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr) # 원소의 개수

for i in range(1 << n): # 부분집합의 개수만큼 반복
  for j in range(n): # 원소의 수만큼 비트를 비교함
    if i & (i << j): # i의 j번 비트가 1인 경우
      print(arr[j], end=',') # j번 원소 출력
```


<br/><br/>

---

# 검색
- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 목적하는 탐색 키를 가진 항목을 찾는 것
  - 탐색 키 : 자료를 구별하여 인식할 수 있는 키

1. 순차 검색
2. 이진 검색
3. 해쉬

<br/><br/>

## 1. 순차 검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 장점 : 간단, 직관적, 알고리즘 단순
- 단점 : 검색 대상이 많은 경우 비효율적

<br/>

### 정렬 ❌
#### 🔎 검색 과정
- 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾음
- 키 값이 동일한 원소를 찾으면 그 원소의 인덱스 반환
- 자료구조의 마지막까지 검색 대상을 찾지 못하면 검색 실패

#### 🔎 특징
- 찾고자 하는 원소의 순서에 따라 비교횟수가 결정됨
- 시간 복잡도 : O(n)

<br/>

### 정렬 ⭕
#### 🔎 검색 과정
- 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면(오름차순) / 작으면(내림차순) 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색 종료

#### 🔎 특징
- 찾고자 하는 원소의 순서에 따라 비교횟수가 결정됨 
  - ➡️ 정렬이 되어 있으므로, 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어듦
- 시간 복잡도 : O(n)


<br/><br/>

## 2. 이진 검색
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
- 정렬된 자료만 가능

#### 🔎 검색 과정
- 자료의 중앙에 있는 원소를 고름
- 중앙 원소 값과 찾고자 하는 목표 값 비교
- if 목표 값 < 중앙 원소 값:
  - 자료의 왼쪽 반에 대해 새로 검색 수행
- elie 목표 값 > 중앙 원소 값:
  - 자료의 오른쪽 반에 대해 새로 검색 수행
- 찾고자 하는 값을 찾을 때까지 과정 반복

> 재귀함수를 이용하여 이진 검색 구현 가능
``` python
def binary(a, low, high, key):
  if low > high: # 검색 실패
    return False 
  
  else:
    middle = (low + high) // 2

    if key == a[middle]: # 검색 성공
      return True

    elif key < a[middle]:
      return binary(a, low, middle - 1, key) # 자료의 왼쪽 반에 대해 새로 검색 수행

    elif a[middle] < key:
      return binary(a, middle + 1, high, key) # 자료의 오른쪽 반에 대해 새로 검색 수행
```

<br/><br/>

### 인덱스


