# Today I Learned
[그래프](#그래프)  
[DFS](#dfs-깊이우선탐색)  
[BFS](#bfs-너비우선탐색)  
[서로소 집합](#서로소-집합-disjoint-sets)  
[최소 비용 신장 트리 (MST)](#최소-신장-트리-mst)
- [Prim](#prim-알고리즘)
- [Kruskal](#kruskal-알고리즘)  

[최단 경로](#최단-경로)  


<br><br>

# 그래프
◽ 그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계 표현  
◽ 그래프 = 정점들의 집합 + 이를 연결하는 간선들의 집합
- |V| : 정점의 개수
- |E| : 그래프에 포함된 간선의 개수
  > 트리 : e = v - 1  
  > but 그래프에서는 그렇지 않음
- |V|개의 정점을 가지는 그래프는 최대 |V|(|V| - 1) / 2 간선이 가능
  > |V| = 5, 최대 간선 수 = 5 * 4 / 2 = 10
◽ N:N 관계를 가지는 원소들을 표현하기 용이

<br><br>

### 📌 그래프 유형
◽ 무방향 그래프  
◽ 유방향 그래프  
◽ 가중치 그래프  
◽ 사이클 없는 방향 그래프 (DAG) : 자기 자신으로 되돌아오는 사이클이 없는 그래프  
◽ 완전 그래프 : 정점들에 대해 가능한 모든 간선들을 가진 그래프  
◽ 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프  

<br>

### 📌 인접
◽ 두 개의 정점에 간선이 존재하면 서로 인접해 있다고 함
◽ 완전 그래프에 속한 임의의 두 정점들은 모두 인접

<br>

### 📌 그래프 경로
◽ 간선들을 순서대로 나열한 것  
◽ **단순 경로** : 경로 중 한 정점을 최대한 한번만 지나는 경로  
◽ **사이클** :  시작한 정점에서 끝나는 경로

<br>

### 📌 그래프 표현
#### 🔗[인접.py](%EC%9D%B8%EC%A0%91.py)

◽ **인접 행렬**
- |V| x |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점과 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0
> ▶ 무방향 그래프  
> A[a][b] = 1  
> A[b][a] = 1
> 
> ▶ 유방향 그래프  
> A[a][b] = 1

🔎 무방향 그래프
![image](https://user-images.githubusercontent.com/93974908/192660274-0af8100c-cf39-4b0c-b25c-61c3d62a6dc9.png)

🔎 유방향 그래프
![image](https://user-images.githubusercontent.com/93974908/192660341-4abf8677-db1a-4967-a3d6-d88ec3f7060e.png)

- 단점 : 정점이 10000개이면 이차원 리스트 X (이차원 리스트는 1000x1000까지만 만들자)

<br>

◽ **인접 리스트**
- 각 정점마다 해당 정점으로 나가는 간선 정보 저장

🔎 무방향 그래프
![image](https://user-images.githubusercontent.com/93974908/192661550-b179c4af-9113-489e-a687-6deba623938d.png)

🔎 유방향 그래프
![image](https://user-images.githubusercontent.com/93974908/192661600-5b7956f1-8e0e-4548-b4ee-2bb709b375a0.png)


<br>

◽ 간선의 배열
- 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장


<br><br>

---
<br>

그래프 순회 : 비선형구조인 그래프로 표현된 모든 자료를 **빠짐없이** 탐색하는 것
- 깊이 우선 탐색 (DFS)
- 너비 우선 탐색 (BFS)

<br>

---

# DFS (깊이우선탐색)
◽ 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법  
◽ 스택 (후입선출) 사용

<br>

### 스택 (stack)
◽ 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조  
◽ 선형 구조 : 1대1 관계  
◽ 후입선출 (LIFO)  

◽ 스택 구현 = 저장소 + 연산
- push : 삽입
- pop : 삭제
- isEmpty : 공백인지 아닌지
- peek : top원소 반환

<br><br>

---

# BFS (너비우선탐색)
◽ 탐색 시작점의 인접한 정점들을 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식  
◽ 큐 (선입선출) 사용

<br>

### 큐 (queue)
◽ 뒤에서는 삽입만, 앞에서는 삭제만  
◽ 선입선출 (FIFO)

◽ 큐 구현
- enQueue : 삽입
- deQueue : 삭제
- isEmpty
- isFull

<br>

🔎 BFS 탐색 순서
![image](https://user-images.githubusercontent.com/93974908/192667423-6af2858b-7786-4c48-b008-040138032c3d.png)


<br><br>

---

# 서로소 집합 (Disjoint-sets)
◽ 서로 중복 포함된 원소가 없는 집합들 (교집합 X)  
◽ 대표자 : 집합에 속한 하나의 특정 멤버를 통해 각 집합을 구분  

<br>

◽ 상호배타 집합을 표현하는 방법
- 연결 리스트
- 트리

<br>

◽ 상호배타 집합 연산
- Make-Set(x)
- Find-Set(x)
- Union(x, y)

### 🔗[union_find.py](code/그래프/union_find.py)

<br>

◽ 상호배타 집합 표현 - 트리  
하나의 집합을 하나의 트리로 표현  
자식 노드가 부모 노드를 가리킴  
대표자 (자기 자신을 가리킴) : 루트 노드  

![image](https://user-images.githubusercontent.com/93974908/192672467-ac0b00a6-a05f-439e-9f92-9fe0613171e8.png)

![image](https://user-images.githubusercontent.com/93974908/192672982-7ebf651c-392a-4f63-b277-145471653a13.png)

> **Union(d, f)**  
> 
> 1️⃣ d의 대표 원소를 찾고   
> 2️⃣ f의 대표 원소를 찾아서  
> 3️⃣ f의 대표 원소를 d의 대표 원소로 교체  


<br><br> 

---

# 최소 신장 트리 (MST)
◽ 그래프에서 최소 비용 문제  
1️⃣ 모든 정점을 연결하는 가중치의 합이 최소가 되는 트리  
2️⃣ 두 정점 사이의 최소 비용의 경로 찾기  

◽ **신장 트리**  
n개의 정점으로 이루어진 **무방향 그래프**에서 n개의 정점과 n-1개의 간선으로 이루어진 트리  

◽ **최소 신장 트리**  (Minimum Spanning Tree) 
무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

<br><br>

## Prim 알고리즘
◽ 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식  

1️⃣ 임의 정점을 하나 선택해서 시작
  > 어차피 그래프의 모든 정점은 MST 연결에 포함이 됨

2️⃣ 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택  
  > 단, 택했을 때 사이클이 만들어지면 X

3️⃣ 모든 정점이 선택될 때까지 1, 2 과정을 반복

<br>

◽ 서로소인 2개의 집합 정보를 유지
- 트리 정점들 : MST를 만들기 위해 선택 O
- 비트리 정점들 : 선택 X

◽ **BUT** 정점의 개수가 많아지면, 인접 행렬의 낭비가 심함

<br><br>

## Kruskal 알고리즘
◽ 간선을 하나씩 선택해서 MST를 찾는 알고리즘  
1️⃣ 최초, 모든 간선을 가중치에 따라 오름차순 정렬 

2️⃣ 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴  
  > 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택

3️⃣ n - 1개의 간선이 선택될 때까지 2 반복

<br><br>

---

# 최단 경로
◽ 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중 간선의 가중치의 합이 최소인 경로

◽ 하나의 시작 정점에서 끝 정점까지의 최단 경로  
▶ 다익스트라 알고리즘 : 음의 가중치 X  
▶ 벨만-포드 알고리즘 : 음의 가중치 O  

◽ 모든 정점들에 대한 최단 경로  
▶ 플로이드-워샬 알고리즘

<br><br>

## Dijkstra 알고리즘
◽ 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단경로 구함  
◽ 시작 정점(s)에서 끝정점(t)까지의 최단 경로에 정점 x 존재  
◽ 이때, 최단경로는 s에서 x까지의 최단경로와 x에서 t까지의 최단경로로 구성됨  

◽ 탐욕 기법 사용  
◽ 프림 알고리즘과 유사

![image](https://user-images.githubusercontent.com/93974908/192702232-c1dc7d1d-242f-4142-8715-53c2aea90d6d.png)
